# 타입 호환성 (Type Compatibility)

> **이 글은 Toss Tech의 TypeScript 타입 시스템 뜯어보기: 타입 호환성 글을 참고하여 공부 차원에서 작성한 글입니다.**

최근에 이펙티브 타입스크립트를 완독하고, 구조적 타이핑에 대해서 조금 헷갈리는 부분이 있어서 확실하게 이해를 하고 들어가보려고 한다.

> **TypeScript의 타입 호환성은 구조적 서브타이핑(Structural Subtyping)을 기반으로 한다. 구조적 타이핑이란 멤버만으로 타입을 관계시키는 방식이다.** > **명목적 타이핑(Nominal Typing)과는 대조적이다. TypeScript의 구조적 타입 시스템의 기본 규칙은 y가 최소한 x의 동일한 멤버를 가지고 있다면 x와 y는 호환되는 것이다.**

## Food와 햄버거 예제

```typescript
type Food = {
  /** 각 영양소에 대한 gram 중량값 */
  protein: number;
  carbohydrates: number;
  fat: number;
};

function calculateCalorie(food: Food) {
  return food.protein * 4 + food.carbohydrates * 4 + food.fat * 9;
}
```

여기서 개발자가 코드를 작성하는 과정에서 의도했거나 실수로 `calculateCalorie` 함수의 매개변수로 여러가지 타입의 객체를 전달한다고 가정해보자. 지금 함수는 Food 타입의 객체를 허용하고 있다. 그런데 컴퓨터 타입을 넣으면 에러가 발생할 것이다.

**만약에, 햄버거 타입의 객체가 들어온다면 어떻게 할 것인가?**

```typescript
/** Food 타입을 상속하면서 칼로리 계산에 필요한 모든 프로퍼티를 포함하고 있음 */
type Burger = Food & {
  burgerBrand: string;
};
```

**햄버거 타입은 실제로 정상적으로 동작할 수 있는 올바른 코드이기 때문에 이런 유연성을 위해 TypeScript 타입 시스템은 부분적으로 타입 호환을 지원하고 있다.**

그렇지만 컴퓨터 타입처럼 확실하게 타입오류로 판단해야하는 경우에는 유연함을 제공하는 것은 옳지 않다. 그래서 어떤 경우에 호환을 허용할 것인지에 대한 명확한 규칙이 필요한데 대표적으로 `명목적 서브타이핑(Nominal Subtyping)`과 `구조적 서브타이핑(Structural Subtyping)`이 있다.

## 명목적 서브타이핑(Nominal Subtyping)

> **타입 정의시에 상속 관계임을 명확히 명시한 경우에만 타입 호환을 허용하는 것이다.** 이 방법을 통해 타입 오류가 발생할 가능성을 배제하고 개발자의 명확한 의도를 반영한다.

```typescript
type Burger = Food & {
  burgerBrand: string;
};

const burger: Burger = {
  protein: 29,
  carbohydrates: 48,
  fat: 13,
  burgerBrand: "버거킹",
};

const calorie = calculateCalorie(burger); // OK!
```

## 구조적 서브타이핑(Structural Subtyping)

> **상속 관계가 명시되어 있지 않더라도 객체의 Property를 기반으로 사용처에서 사용함에 문제가 없으면 타입 호환을 허용하는 방식이다.**

```typescript
const burger = {
  protein: 29,
  carbohydrates: 48,
  fat: 13,
  burgerBrand: "버거킹",
};

const calorie = calculateCalorie(burger); // OK!
```

- 구조적 서브타이핑 방식은 타입 시스템이 객체의 프로퍼티를 체크하는 과정을 수행해주면서 명목적 서브타이핑과 동일한 효과를 내면서 개발자가 상속 관계를 명시해주어야 하는 수고를 덜어준다.
- 구조적 서브타이핑은 "만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다." 라는 의미에서 `Duck Typing`이라고도 부른다.
- **TypeScript의 Type-Checker는 구조적 서브타이핑을 기반으로 타입 호환을 판단한다.** 그리고 명목적 서브타이핑만 지원하는 C#과 Java 등의 언어는 명시적으로 상속 관계를 명시해주어야만 타입 호환이 가능하다.

## 추가 예외 상황
